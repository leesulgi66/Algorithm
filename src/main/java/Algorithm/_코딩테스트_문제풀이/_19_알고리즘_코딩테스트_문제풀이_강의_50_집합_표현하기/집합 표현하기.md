# 집합 표현하기

[문제 링크](https://www.acmicpc.net/problem/1717)

### 문제
초기에 n+1개의 집합
{0}, {1}, {2},...,{n}이 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하려고 한다.

집합을 표현하는 프로그램을 작성하시오.

### 입력
첫째 줄에
n,
m이 주어진다.
m은 입력으로 주어지는 연산의 개수이다. 다음
m개의 줄에는 각각의 연산이 주어진다. 합집합은
0
a
b의 형태로 입력이 주어진다. 이는
a가 포함되어 있는 집합과,
b가 포함되어 있는 집합을 합친다는 의미이다. 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산은
1
a
b의 형태로 입력이 주어진다. 이는
a와
b가 같은 집합에 포함되어 있는지를 확인하는 연산이다.

### 출력
1로 시작하는 입력에 대해서
a와
b가 같은 집합에 포함되어 있으면 "YES" 또는 "yes"를, 그렇지 않다면 "NO" 또는 "no"를 한 줄에 하나씩 출력한다.

***

| 예제 입력1 | 예제 출력2 |
|--------|--------|
| 7 8    | NO     |
| 0 1 3  | NO     |
| 1 1 7  | YES    |
| 0 7 6  |
| 1 7 1  |
| 0 3 7  |
| 0 4 2  |
| 0 1 1  |
| 1 1 1  |

___

#### 01 문제 분석하기
최대 원소의 개수 1,000,000과 질의 개수 100,000이 큰 편이므로 경로 압축이 필요한 전형적인 유니온 파인드 문제입니다. 
앞에서 설명했던 핵심 이론을 실제 코드로 구현하면서 유니온 파인드에 원리에 관해 좀 더 정확하게 이해하길 바랍니다.


#### 02 손으로 풀어보기

1. 처음에는 노드가 연결돼 있지 않으므로 각 노드의 대표 노드는 자기 자신 입니다. 각 노드의 값을 자기 인덱스값으로 초기화합니다.
   ![집합 표현 1](https://github.com/leesulgi66/Algorithm/assets/107823688/7c47eb2f-b049-46bd-8f4c-67aad677caa9)
2. find 연산으로 특정 노드의 대표 노드를 찾고, union 연산으로 2개의 노드를 이용해 각 대표 노드를 찾아 연결합니다. 그리고 질의한 값에 따라 결과를 반환합니다.
   ![집합 표현 2](https://github.com/leesulgi66/Algorithm/assets/107823688/85717ab8-8c64-44fd-b87f-505f2fa8dfdf)

##### 유니온 파인드에서 자주 실수하는 부분
find 연산을 수핼할 때 재귀 함수에서 나오면서 탐색한 **모든 노드의 대표 노드값을 이번 연산에서 발견한 
대표 노드로 변경**하는 부분과, union 연산에서 선택된 노드끼리의 연결하는 것이 아닌 
**선택된 노드의 대표 노드끼리 연결하는 부분**이 유이온 파인드에서 가장 많이 실수하는 부분입니다.

#### 03 슈도코드 작성하기
```java
N(원소 개수) M(질의 개수)
parent(대표 노드 저장 배열)
수열 배열 채우기
for(N만큽 반복하기) {
    대표 노드를 자기 자신으로 초기화하기
}
for(M만큼 반복하기) {
    if(0이면) 집합 합치기 -> union 연산
    else와 같은 집합 원소인지 확인하고 결괏값 출력하기
}
// union 연산
union(a, b){
    a와 b의 대표 노드 찾기
    두 원소의 대표 노드끼리 연결하기
}
// find 연산
find(a) {
    a가 대표 노드면 리턴
    아니면 a의 대표 노드값을 find(parent[a]) 값으로 저장 -> 재귀 함수 형태
}
// checkSame -> 두 원소가 같은 집합인지 확인
checkSame(a, b) {
    a와 b의 대표 노드 찾기
        두 대표노드가 같으면 true
        아니면 false return
}

```
