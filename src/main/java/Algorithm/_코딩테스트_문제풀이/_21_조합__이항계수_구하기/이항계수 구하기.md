# 이항계수 구하기

[문제 링크](https://www.acmicpc.net/problem/11050)

### 문제
![1](https://github.com/leesulgi66/Algorithm/assets/107823688/e77a4780-409e-4e08-a114-03d3c437d6d1)


### 입력
![2](https://github.com/leesulgi66/Algorithm/assets/107823688/e02de661-9474-4864-bce2-54d808712292)


### 출력
![화면 캡처 2023-07-21 155009](https://github.com/leesulgi66/Algorithm/assets/107823688/22cfa26e-e6b2-4ac1-8225-69acea189341)


***

| 예제 입력1     | 예제 출력1 |
|------------|--------|
| 5 2 // N K | 10     |


___

#### 01 문제 분석하기
조합에서 가장 기본이 되는 문제입니다. 앞에서 배운 핵심 이론의 일반 전화식을 이용하면 
이 문제를 쉽게 해결할 수 있습니다.

#### 02 손으로 풀어보기
1. N과 K의 값을 입력받고 DP 배열을 선언합니다.(D[N+1][N+1]). 그리고 DP 배열의 
값을 다음과 같이 초기화 합니다.  
<br>**DP 배열 초기화**  
D[i][1] = i // i개 중 1개를 뽑는 경우의 수는 i개 (ex : 5개중 1가지를 뽑는 경우는 1~5 5가지)  
D[i][0] = 1 // i개 중 1개도 선택하지 않는 경우의 수는 1개 (ex : 5개중 아무것도 뽑지 않는 경우 1가지)  
D[i][i] = 1 // i개 중 i개를 선택하는 경우의 수는 1개 (ex : 5개중 5개를 모두 뽑는 경우 1가지)  
미리 세가지 경우에 대해서 초기화를 해주는 것이 중요합니다.  
<br>   ![이항계수 1](https://github.com/leesulgi66/Algorithm/assets/107823688/07811f56-18de-4428-923c-1dd9f56e8915)  <br>
2. 점화식으로 DP 배열의 값을 채웁니다.  
D[i][j] = D[i-1][j-1] + D[i-1][j]  
<br>![이항계수 2](https://github.com/leesulgi66/Algorithm/assets/107823688/838b0b36-6722-4f74-bf94-aa3a487500b2)<br>  
3. D[N][K]의 값을 출력합니다.  
<br>![이항계수 3](https://github.com/leesulgi66/Algorithm/assets/107823688/64230122-084e-4878-aab3-b42dbff14e7d)<br>

#### 03 슈도코드 작성하기
```java
N(총 개수), K(선택 수)
D(DP 배열)
for(i -> N만큽 반복하기) {
    D 배열 초기화 하기
    D[i][1] = i // i개에서 1개가 선택 경우의 수는 i개
    D[i][0] = 1 // i개에서 1개도 선택하지 않는 경우의 수는 0개
    D[i][i] = 1 // i개에서 모두 선택하는 경우의 수는 1개
}
for(i -> N만큼 반복하기) {
    for(j -> i 만큼 반복하기) {
        D[i][j] = D[i-1][j] + D[i-1][j-1]; // 조합 점화식
    }
}
D[N][K] 출력하기

```
