# 제목

[문제 링크](https://www.acmicpc.net/problem/1920)

### 문제
N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.

### 입력
첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.

### 출력
M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.

***

<table class="table">
        <thead><tr>
<th>예제 입력 1</th>
<th>예제 출력 1</th>
</tr>
</thead>
        <tbody><tr>
<td>5  // 데이터 개수    </td>
<td>1     </td>
</tr>
<tr>
<td>4 1 5 2 3     </td>
<td>1     </td>
</tr>
<tr>
<td>5  // 찾아야 할 숫자 개수     </td>
<td>0   </td>
</tr>
<tr>
<td>1 3 7 9 5       </td>
<td>0     </td>
</tr>
<tr>
<td>     </td>
<td>1     </td>
</tr>
</tbody>
      </table>

___

#### 01 문제 분석하기
N의 최대 범위가 100,000이므로 단순 반복문으로는 이 문제를 풀 수 없습니다. 이진 탐색을 적용하면 O(nlogn)시간 복잡도로 해결할 수 있으므로 이진 탐색을 적용합시다. 앞에서 언급했듯이 이진 탐색은 정렬을 가정하므로 정렬 함수도 사용합니다.  
▶자바의 기본 정렬을 O(nlogn)의 시간복잡도를 가지므로 정렬을 수행해도 제한 시간을 초고하지 않습니다.


#### 02 손으로 풀어보기
1. 탐색 데이터를 1차원 배열에 저장한 다음 저장된 배열을 정렬합니다.
   ![정수찾기 1](https://github.com/leesulgi66/Algorithm/assets/107823688/90fafea8-1848-4787-be6a-8865299bf498)
2. X라는 정수가 존재하는지 이진 탐색을 사용해 확인합니다.
   ![정수찾기 2](https://github.com/leesulgi66/Algorithm/assets/107823688/c273a5a8-440e-40ed-a3d3-8061506e5708)
   ![정수찾기 3](https://github.com/leesulgi66/Algorithm/assets/107823688/baa4f5cb-9be7-44f0-88e9-7f0ece740f81)

#### 03 슈도코드 작성하기
```java
N(정렬할 수 개수) M(탐색할 숫자의 개수)
A(정렬할 배열 선언하기)
for(N의 개수만큼 반복하기){
    A 배열 저장하기
}
A배열 정렬하기
        
for(M의 개수만큼 반복하기){
    target(찾아야 하는 수)
    // 이진 탐색 시작
    start(시작 인덱스),
    end(종료 인덱스)
        while(시작 인덱스 <= 종료 인덱스){
            midi(중간 인덱스)
            if(중앙값 > target) {
                종료 인덱스 = 중간 인덱스 -1
            }else if(중앙값 < target) {
                시작 인덱스 = 중간 인덱스 +1
            }else {
                찾았으므로 반복문 종료하기
            }
        }
    if(찾았음) 1 출력
    else 0 출력
}
```
