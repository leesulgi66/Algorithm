# 세그먼트 트리
주어진 데이터의 구간 합과 데이터 업데이트를 빠르게 수행하기 위해 고안해낸 자료구조의 
형태가 바로 세그먼트 트리입니다. 더 큰 범위는 '인덱스 트리'라고 불리는데, 코딩 테스트 
영역에서는 큰 차이가 없다고 생각해도 됩니다.

### 세그먼트 트리의 핵심 이론
세그먼트 트리의 종류는 구간 합, 최대ㆍ최소 구하기로 나눌 수 있고, 구현 단계는 트리 
초기화하기, 질의값 구하기(구간 합, 최대ㆍ최소),데이터 업데이트하기로 나눌 수 있습니다. 
단계별로 좀 더 자세하게 설명하겠습니다.

#### 1. 트리 초기화하기
리프 노드의 개수가 데이터의 개수(N) 이상이 되도록 트리 배열을 만듭니다. 트리 배열의 
크기를 구하는 방법은 **2^k >= N 을 만족하는 k의 최솟값을 구한 후 2^k * 2를 트리 배열의 
크기**로 정의하면 됩니다. 예를 들어 다음과 같은 샘플 데이터가 있다면 N=8이므로 2³>=8이므로 
배열의 크기를 2³*2=16으로 정의합니다.  
###### 샘플 데이터
{5,8,4,3,7,2,1,6}

리프 노드에 원본 데이터를 입력해야 합니다. 이때 리프 노드의 시작 위치를 트리 배열의 
인덱스로 구해야 하는데, 구하는 방식은 2^k를 시작 인덱스로 취하면 됩니다. 예를 들어 
k의 값이 3이면 start index = 8 이 됩니다.  
![세그먼트 트리 1](https://github.com/leesulgi66/Algorithm/assets/107823688/92163231-0122-403e-b73a-392b7edb0c9c)  
리프 노드를 제외한 나머지 노드의 값을 채웁니다.(2^k-1부터 1번 쪽으로 채웁니다.) 채워야 하는 
인덱스가 N이라고 가정하면 자신의 자식 노드를 이용해 해당 값을 채울 수 있습니다. 자식 
노드의 인덱스는 이진 트리 형식이기 때문에 2N, 2N+1이 됩니다. 케이스별로 적절하게 계산합니다.

![세그먼트 트리 2](https://github.com/leesulgi66/Algorithm/assets/107823688/bc90ac1f-693e-4670-bdfd-0d6fb839b17d)  

샘플을 이용해 3개의 케이스와 관련된 세그먼트 트리를 구성해 봤습니다. 구성한 트리 배열을 
실제 트리 모양으로 구조화하면 다음과 같이 표현할 수 있습니다.  

![세그먼트 트리 3](https://github.com/leesulgi66/Algorithm/assets/107823688/d1b63d9c-0b62-44e5-85bf-722666ffe474)

이렇게 세그먼트 트리를 구성해 놓으면 그 이후 질의와 관련된 결괏값이나 데이터 업데이트 
요구 사항에 관해 좀 더 빠른 시간 복잡도 안에서 해결할 수 있게 됩니다.

#### 2. 질의값 구하기
주어진 질의 인덱스를 세그먼트 트리의 리프 노드에 해당하는 인덱스로 변경합니다. 기존 샘플을 
기준으로 한 인덱스값과 세그먼트 트리 배열에서의 인덱스값이 다르기 때문에 인덱스를 변경해야 합니다. 
인덱스 변경 방법은 다음과 같습니다.

##### 질의 인덱스를 세그먼트 트리 인덱스로 변경하는 방법
세그먼트 트리 index = 주어진 질의 index + 2^k - 1  // 샘플에서는 k = 3

질의에서의 시작 인덱스와 종료 인덱스에 관해 부모 노드로 이동하면서 주어진 질의에 
해당하는 값을 다음과 같이 구합니다.

![세그먼트 트리 4](https://github.com/leesulgi66/Algorithm/assets/107823688/07734475-346f-43cc-9ae1-9d97a5fd9f02)

①~②에서 해당 노드를 선택했다는 것은 해당 노드의 부모가 나타내는 범위가 질의 범위를 
넘어가기 때문에 해당 노드를 질의값에 영향을 미치는 독립 노드로 선택하고, 해당 노드의 
부모 노드는 대상 범위에서 제외한다는 뜻입니다. 부모 노드를 대상 범위에서 제거하는 방법은 
바로 ③~④에서 질의 범위에 해당하는 부모 노드를 이동하기 위해 인덱스 연산을 index/2가 
아닌 (index+1)/2, (index-1)/2로 수행하는 것입니다.

질의에 해당하는 노드를 선택하는 방법은 구간 합, 최댓값 구하기, 최솟값 구하기 모두 
동일하며 선택된 노드들에 관해 마지막에 연산하는 방식만 다릅니다.
##### 질의에 해당하는 노드 선택 방법
- 구간 합 : 선태고딘 노드를 모두 더한다.
- 최대값 구하기 : 선택된 노드 중 MAX값을 선택해 출력한다.
- 최솟값 구하기 : 선택된 노드 중 MIN값을 선택해 출력한다.

트리 초기화하기에서 나온 구간 합 샘플을 이용해 2~6번째 구간합을 구하는 간단한 예제를 
살펴보겠습니다.

먼저 리프 노드의 인덱스로 변경합니다.  
![세그먼트 트리 5](https://github.com/leesulgi66/Algorithm/assets/107823688/54f05db3-6ca0-44ce-8db7-bfac44730466)

부모 노드로 이동합니다.  
![세그먼트 트리 6](https://github.com/leesulgi66/Algorithm/assets/107823688/d4e63002-45ec-41a5-8b88-951ee7dcb8d5)

한번 더 부모 노드로 이동합니다.  
![세그먼트 트리 7](https://github.com/leesulgi66/Algorithm/assets/107823688/c9b4e0c0-e5b1-4b3a-9152-a5a256e632c6)

end_index < start_index 이므로 종료하고 값을 구합니다. 2~6번 구간 합의 값은 선택된 
노도의 합인 8+9+7 = 24 가 됩니다.

#### 3. 데이터 업데이트하기
업데이트 방식은 자신의 부모 노드로 이동하면서 업데이트한다는 것은 동일하지만, 어떤 
값으로 업데이트 할것인지에 관해서는 트리 타입별로 조금 다릅니다.
###### ※부모 노드로 이동하는 방식은 세그먼트 트리가 이진 트리이므로 index = index/2로 변경하면 됩니다.
구간 합에서는 원래 데이터와 변경 데이터의 차이만큼 부모 노드로 올라가면서 병경합니다. 
최댓값 찾기에서는 변경 데이터와 자신과 같은 부모를 지니고 있는 다른 자식 노드와 비교해 
더 큰 값으로 업데이트합니다. 업데이트가 일어나지 않으면 종료합니다. 마지막으로 최솟값 
찾기에서는 변경 데이터와 자신과 같은 부모를 지니고 있는 다른 자식 노드와 비교해 더 작은 
값으로 업데이트합니다. 업데티으가 일어나지 않으면 종료합니다.

다음은 5번 데이터의 값을 7에서 10으로 업데이트하는 예시입니다. 5번 데이터의 인덱스를 
리프 노드 인덱스로 변경하면서 5+7=12 이므로 12번 노드의 값이 업데이트됩니다.  
![세그먼트 트리 8](https://github.com/leesulgi66/Algorithm/assets/107823688/a89c5fc3-db2a-4278-9cfe-128883265f82)

