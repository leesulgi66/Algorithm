# 소수 구하기(에라토스테네스의 체)
소수(prime number)는 자신보다 작은 2개의 자연수를 곱해 만들 수 없는 1보다 큰 자연수를 말합니다. 
이와 같은 의미로 1과 자기 자신 외에 약수가 존재하지 않는 수를 말합니다. 코딩 테스트에서는 
이러한 소수를 판별하는 방식을 묻는 소수 구하기 문제가 종종 출제됩니다.

### 소수 구하기의 핵심 이론
소수를 구하는 대표적인 판별법으로는 에라토스테네스의 체를 들 수 있습니다. 에라토스테네스의 체 원리는 다음과 같습니다.

#### 에라토스테네스의 체 원리
1. 구하고자 하는 소수의 범위만큼 1차원 배열을 생성합니다.
2. 2부터 시작하고 현재 숫자가 지워지지 않을 때는 현재 선택된 숫자의 배수에 해당하는 수를 배열에서 끝까지 탐색하면서 지웁니다. 이때 처음으로 선택된 숫자는 지우지 않습니다.
3. 배열의 끝까지 2.를 반복한 후 배열에 남아 있는 모든 수를 출력합니다.

### 에라토스테네스의 체의 원리 이해하기
1부터 30까지의 수 중 소수를 구하는 예시를 보면서 에라토스테네스의 체의 원리를 알아보겠습니다.
1. 먼저 주어진 범위까지 배열을 생성합니다. 1은 소수가 아니므로 삭제하고, 배열은 2부터 시작합니다.
   ![에라토스테네스의 체 1](https://github.com/leesulgi66/Algorithm/assets/107823688/4be7c93d-5dfc-4fac-989e-e8688504ba65)
2. 선택한 수의 배수를 모두 삭제합니다. 현재의 경우 2의 배수를 모두 삭제했습니다.
   ![에라토스테네스의 체 2](https://github.com/leesulgi66/Algorithm/assets/107823688/f506de04-41bd-463b-85b3-1913c0147db7)
3. 다음 지워지지 않은 수를 선택합니다. 즉, 3을 선택하고 선택한 수의 모든 배수를 삭제합니다. 이미 지운 수는 다시 지우지 않습니다.
   ![에라토스테네스의 체 3](https://github.com/leesulgi66/Algorithm/assets/107823688/da95af7e-9392-4744-b218-ec66f0e6efd7)
4. 앞의 과정을 배열의 끝까지 반복합니다.
   ![에라토스테네스의 체 4](https://github.com/leesulgi66/Algorithm/assets/107823688/3a3bbf32-e8e8-4cc7-8556-976d8d9f627a)
5. 삭제되지 않은 수를 모두 출력합니다.
   ![에라토스테네스의 체 5](https://github.com/leesulgi66/Algorithm/assets/107823688/be9ee0e5-f9dc-4b4d-9a47-e103d6cb360c)

<br>

##### ※에라토스테네스의 체를 사용할 때 시간 복잡도는?
일반적으로 에라토스테네스의 체를 구현하려면 이중for문을 이용하므로 시간 복잡도가 O(N²)정도라고 
판달할 수 있습니다. 하지만 실제 시간 복잡도는 최적화의 정도에 따라 다르겠지만, 
일반적으로 O(Nolg(logN))입니다. 그 이유는 배수를 삭제하는 연산으로 실제 구현에서 
밖깥쪽 for문을 생략하는 경우가 빈번하게 발생하기 때문입니다. 이러한 이유 때문에
에라토스테네스의 체 기법은 현재에도 코딩 테스트에서 소수를 구하는 일반적인 방법으로 통용되고 있습니다.

##### ※N의 제곱근까지만 탐색하는 이유
N이 a*b라고 가정했을 때, a와b 모두 N의 제곱근보다 클 수 없습니다.
따라서 N의 제곱근까지만 확인해도 전체 범위의 소수를 판별할 수 있습니다.
만약 16의 범위까지 소수를 구할 때 16 = 4 * 4로 이뤄지면 16보다 작은 숫자는
항상 4보다 작은 약수를 갖게 된다는 뜻이 됩니다. 따라서 4까지만 확인하고
소수 판별을 진행하면 됩니다.