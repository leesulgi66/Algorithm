# 동적 계획법(dynamic programming)
동적 계획법은 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 
최정적으로 복잡한 문제의 답을 구하는 방법을 뜻합니다.

### 동적 계획법의 핵심 이론 
동적 계획법의 원리와 구현 방식은 다음과 같습니다.

##### *동적 계획법의 원리와 구현 방식*
1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
2. 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결괏값은 항상 같아야 한다.
3. 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며 추후 재사용할 때는 이 DP 테이블을 이용한다. 이를 메모이제이션(memoization) 기법이라고 한다.
4. 동적 계획법은 톱-다운 방식과 바텀-업 방식으로 구현할 수 있다.

동적 계획법의 가장 대표적인 문제인 피보나치 수열을 예로들어 설명하겠습니다.

<br>

##### *피보나치 수열 공식*
D[N] = D[N-1] + D[N-1]  // N번째 수열 = N-1번째 수열 + N-2번째 수열

<br>

#### 1. 동적 계획법으로 풀수 있는지 확인하기
6번째 피보나치 수열은 5번째 피보나치 수열과 4번째 피보나치 수열의 합입니다. 즉, 
6번째 피보나치 수열을 구하는 문제는 5번째 피보나치 수열과 4번째 피보나치 수열을 구하는 
작은 문제로 나눌 수 있고, 수열의 값은 항상 같기 때문에 동적 계획법으로 풀 수 있습니다.

#### 2. 점화식 세우기
점화식을 세울 때는 논리적으롤 전체 문제를 나누고, 전체 문제와 부분 문제 간의 인과 
관계를 파악하는 훈련이 필요합니다. 이 부분은 다양한 실전 문제를 풀면서 자연스럽게 
훈련되므로 걱정하지 마세요. 이 예제는 피보나치 수열의 공식 자체가 점화식이므로 공식을 
점화식으로 사용하겠습니다. 즉, 피보나치 수열의 점하식은 D[N] = D[N-1] + D[N-1]이 됩니다. 

#### 3. 메모이제이션 원리 이해하기
메모이제이션은 부분 문제를 풀었을 때 이 문제를 DP 테이블에 저장해 놓고 다음에 같은 
문제가 나왔을 때 재계산하지 않고 DP 테이블의 값을 이용하는 것을 말합니다. 다음 그림을 
보면 위에서 2번째와 3번째 피보나치 수열은 맨 왼쪽 탐색 부분에서 최초로 값이 구해지고, 
이때 DP 테이블에 값이 저장됩니다. 이에 따라 나중에 2번째와 3번째 피보나치 수열의 값이 
필요할 때 재연산을 이용해 구하지 않고, DP 테이블에서 바로 값을 추출합니다. 이러한 
방식을 사용하면 불필요한 연산과 탐색이 줄어들어 시간 복잡도 측면에서 많으 이점을 가질 수 
있습니다.

![동적 계획법 1](https://github.com/leesulgi66/Algorithm/assets/107823688/60006077-37bb-44b5-8dc0-e95686fad1eb)

#### 4. 톱-다운 구현 방식 이해하기
톱-다운 구현 방식은 말 그대로 위에서부터 문제를 파악해 내려오는 방식으로, 주로 재귀 함수 
형태로 코드를 구현합니다. 코드의 가독성이 좋고, 이해하기가 편하다는 장점이 있습니다.

###### 동적계획법 P2747_피보나치수_TopDown.java

```java
import java.util.Scanner;

public class P2747_TopDown {
    static int[] D;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        D = new int[n + 1];
        for(int i=0; i<=n; i++) {
            D[i] = -1;  // -1값으로 모두 초기화
        }
        
        D[0] = 0;   // 가장 최초의 작은문제
        D[1] = 1;   // 미리 아는 값으로 초기화
        fibo(n);
        System.out.println(D[n]);
    }
    
    static int fibo(int n) {
        if(D[n] != -1) {
            return D[n];
        }
        return D[n] = fibo(n-2)+fibo(n-1);
    }
}
```

#### 5. 바텀-업 구현 방식 이해하기
가장 작은 부분 문제부터 문제를 해결하면서 점점 큰 문제로 확장해 나가는 방식입니다. 
주로 반복문의 형태로 구현합니다. 
###### 동적계획법 P2747_피보나치수_BottomUp.java

```java
import java.util.Scanner;

public class P2747_BottomUp {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        D = new int[n+1];
        for(int i=0; i<=n; i++) {
            D[i] = -1;
        }
        D[0] = 0;
        D[1] = 1;
        for(int i=2; i<=n; i++) {
            D[i] = D[i-1] + D[i-2];
        }
        System.out.println(D[n]);
    }
}
```

두 방식 중 좀 더 안전한 방식은 바텀-업입니다. 톱-다운 방식은 재귀 함수의 형태로 
구현돼있기 때문에 재귀의 깊이가 매우 길어질 경우 런타임 에러가 발생할 수 있습니다. 
하지만 실제 코딩 테스트에서 이 부분까지 고려해야 하는 난이도는 잘 나오지 않습니다. 
오히려 자신이 구현한 함수에 버그가 있을 확률이 더 높을 것입니다. 이 부분을 제외하면 
두 방식의 차이점은 거의 없다고 할 수 있습니다. 자신에게 좀 더 편한 방식이나 문제에 
따라 두 방식 중 1개를 선택해 사용하면 됩니다. 동적 계획법은 매우 중요하므로 가장 많은 
문제를 다룰 예정입니다.