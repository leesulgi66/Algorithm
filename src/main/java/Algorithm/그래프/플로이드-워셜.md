# 플로이드-워셜(floyd-warshall)
플로이드-워셜알고리즘은 그래프에서 최단 거리를 구하는 알고리즘으로, 주요 특징은 다음과 같습니다.

|기능|특징|시간 복잡도(노드 수:V)|
|---|---|---|
|모든 노드간에 최단<br>경로 탐색|- 음수 가중치 에지가 있어도 수행할 수 있음<br>- 동적 계획법의 원리를 이용해 알고리즘에 접근|O(V³)|

### 플로이드-워셜의 핵심 이론
플로이드-워셜 알고리즘을 도출하는 가장 핵심적인 원리는 A 노드에서 B 노드까지 최단 
경로를 구했다고 가정했을 때 최단 경로 위에 K 노드가 존재한다면 그것을 이루는 부분 
경로 역시 최단 경로라는 것입니다. 다음 그림으로 이해해 볼까요?  
![플로이드 워셜 1](https://github.com/leesulgi66/Algorithm/assets/107823688/93e854b7-5412-4fef-a819-682c930d4a49)  
색칠된 에지 경로가 1->5 최단 경로라면 1->4 최단 경로와 4->5 최단 경로 역시 색칠된 에지로 이뤄질 수밖에 없브니다. 즉, 전체 경로의 
최단 경로는 부분 경로의 최단 경로의 조합으로 이뤄진다는 의미가 됩니다. 
이 원리로 다음과 같은 점화식을 도출할 수 있습니다.

#### 도출한 플로이드-워셜 점화식
D[S][E] = Math.min(D[S][E], D[S][K]+D[K][E])  
이 내용을 익힌 후 이제 플로이드-워셜 알고리즘 구현 방법에 관해 자세히 설명하겠습니다.

#### 1. 리스트를 선언하고 초기화하기
D[S][E]는 노드 S에서 노드 E까지의 최단 거리를 저장하는 리스트라 정의합니다. 
S와 E의 값이 같은 칸은 0, 다른 칸은 ∞로 초기화합니다. 여기에서 S == E 는 자기 
자신에게 가는 데 걸리는 최단 결로값을 의미하기 때문입니다.  
![플로이드 워셜 2](https://github.com/leesulgi66/Algorithm/assets/107823688/42446e28-7273-4085-bd01-363a4c7c82c6)

#### 2. 최단 거리 리스트에 그래프 데이터 저장하기
출발 노드는 S, 도착 노드는 E, 이 에지의 가중치는 W 라고 했을 때 D[S][E] = W로 에지의 
정보를 리스트에 입렵합니다. 이로써 플로이드-워셜 알고리즘은 그래프를 인접 행렬로 
표현한다는 것을 알 수 있습니다.  
![플로이드 워셜 3](https://github.com/leesulgi66/Algorithm/assets/107823688/6e4a3743-e2e4-45df-a8b0-ebcc24979748)

#### 3. 점화식으로 리스트 업데이트하기
기존에 구했던 점화식을 3중 for문의 형태로 반복하면서 리스트의 값을 업데이트합니다.
##### 플로이드-워셜 알고리즘 로직
```java
for 경유지 K에 관해(1~N) // N: 노드 개수
    for 출발 노드 S에 관해(1~N)
        for 도착 노드 E에 관해(1~N)
            D[S][E] = Math.min(D[S][E], D[S][K] + D[K][E])
```
![플로이드 워셜 4](https://github.com/leesulgi66/Algorithm/assets/107823688/4746a24f-6b06-4176-a0c1-e12381b431db)  
완성된 리스트는 모든 노드 간의 최단 거리를 알려 줍니다. 예를 들어 1번 노드에서 5번 
노드까지 가는 최단 거리는 D[1][5] = 6 으로 나타난다는 것을 알 수 있습니다.

플로이드-워셜 알고리즘은 모든 노드 간의 최단 거리를 확인해 주기 때문에 시간 복잡도가
O(V³)으로 빠르지 않은 편입니다. 이에 따라 플로이드-워셜 알고리즘을 사용해야 하는 문제가 
나오면 일반적으로 노드 개수의 범위가 다른 그래프에 비해 적게 나타나는 것을 알 수 있습니다.
