# 그래프의 표현
여기서는 그래프를 구현하는 3가지 방법을 알아봅니다. 
그래프 관련 문제 풀이를 위한 필수 과정이므로 확실히 공부하고 
넘어가기 바랍니다.

### 에지 리스트
에지 리스트(edge list)는 에지를 중심으로 그래프를 표현합니다. 에지 리스트는 
배열에 출발 노드, 도착 노드를 저장하여 에지를 표현합니다. 또는 출발 노드, 
도착 노드, 가중치를 저장하여 가중치가 있는 에지를 표현합니다. 다음을 통해 
에지 리스트를 자세히 알아보겠습니다.

#### 에지 리스트로 가중치 없는 그래프 표현하기
가중치가 없는 그래프는 출발 노드와 도착 노드만 표현하므로 배열의 행은 2개면 충분합니다. 
노드는 여러 자료형을 사용할 수 있으며 다음의 경우 노드는 Integer 형 입니다.  
![에지 리스트1](https://github.com/leesulgi66/Algorithm/assets/107823688/7f3551b5-4ccb-423b-936a-1fe8713daf80)
1에서 2로 뻗어나가는 에지는 [1,2]로 표현합니다. 4에서 5로 뻗어나가는 에지는 [4,5]로 
표현합니다. 이처럼 방향이 있는 그래프는 순서에 맞게 노드를 배열에 저장하는 
방식으로 표현합니다. 그리고 노드를 배열에 저장하여 에지를 표현하므로 에지 리스트라 합니다.
###### ▶여기서 방향이 있는 그래프를 예로 들었습니다. 만약 방향이 없는 그래프라면[1,2],[2,1]는 같은 표현일 것입니다.

#### 에지 리스트로 가중치 있는 그래프 표현하기
가중치가 있는 그래프는 행을 3개로 늘려 3번째 행에 가중치를 저장하면 됩니다. 
다음 그림을 봅시다.  
![에지 리스트2](https://github.com/leesulgi66/Algorithm/assets/107823688/ecbb79ff-04ff-4ebc-a6cf-8a36fe7e3d96)
1에서 2로 향하는 가중치가 8인 이제는[1,2,8]로 표현합니다. 이처럼 에지 리스트는 
구현하기 쉽습니다. 하지만 특정 노드와 관련되어 있는 에지를 탐색하기는 
쉽지 않습니다. 에지 리스트는 벨만 포드나 크루스칼(MST) 알고리즘에 사용하며, 
노드 중심 알고리즘에는 잘 사용하지 않습니다.

<br>


### 인접 행렬
인접 행렬(adjacency matrix)은 2차원 배열을 자료구조로 이용하여 그래프를 
표현합니다. 인접행렬은 에지 리스트와 다르게 노드 중심으로 그래프를 표현합니다. 
다음 노드가 5개인 그래프를 5X5 인접 행렬로 표현한 것입니다. 그림으로 인접 행렬을 
자세히 이해해 봅시다.


#### 인접 행렬로 가중치 없는 그래프 표현하기
다음 그림을 보면 1에서 2를 향하는 에지를 인접 행렬은 1행 2열에 1을 저장하는 방식으로 
표현합니다. 1을 저장하는 이유는 *가중치가 없기 때문*입니다. 1에서 2로 향하는 
에지가 있다는 표시를 노드 중심으로 한다고 이해하면 됩니다.  
![인접 행렬](https://github.com/leesulgi66/Algorithm/assets/107823688/f28e77af-b087-4370-adc1-1de6f98841f0)

#### 인접 행렬로 가중치 있는 그래프 표현하기
계속해서 가중치가 있는 그래프 표현도 봅니다. 앞의 가중치가 없는 그래프를 
이해했다면 가중치가 있는 그래프는 그림만 쓱 봐도 쉽게 이해할 수 있을 것입니다. 
2에서 5로 향하는 에치의 가중치를 2행5열에 기록합니다.  
![인접 행렬 가중치](https://github.com/leesulgi66/Algorithm/assets/107823688/9a108082-ea04-4049-9ec4-eab3dfc93228)
이처럼 인접 행렬을 이용한 그래프 구현은 쉽습니다. 두 노드를 연결하는 에지의 
여부와 가중치값은 배열에 직접 접근하면 바로 확인할 수 있는 것도 장점입니다. 
하지만 노드와 관련되어있는 에지를 탐색하려면 N번 접근해야 하므로 노드 개수에 
비해 에지가 적을 때는 공간 효율성이 떨어집니다. 또한 노드 개수가 많은 경우 
아예 2차원 배열 선언 자체를 할 수 없는 결함도 있습니다. 따라서 인접 행렬은 
노드 개수에 따라 사용 여부를 적절하게 판단하는 능력도 필요합니다. 예를 들어 
노드가 3만 개가 넘으면 자바 힙 스페이스(java heap space)에러가 발생합니다.

<br>

### ★인접 리스트
인접 리스트(adjacency list)는 ArrayList로 그래프를 표현합니다. 노드 
개수만큼 ArrayList를 선언 합니다. 자료형은 경우에 맞게 사용합니다. 다음 
그림으로 이해해 볼까요?

#### 인접 리스트로 가중치 없는 그래프 표현하기
다음은 인접 리스트로 가중치 없는 그래프를 표현한 것입니다. 현재의 경우 Integer 형이면 
그래프를 표현하기에 충분하므로 ArrayList<Integer>[5]로 선언했습니다. 
인접 리스트에는 N번 노드와 연결되어 있는 노드를 배열의 위치 N에 연결된 
노드 개수만큼 배열을 연결하는 방식으로 표현합니다.  
![인접 리스트1](https://github.com/leesulgi66/Algorithm/assets/107823688/8b60815b-a107-4d8f-b3c1-dd32043c5343)
예를 들어 노드 1과 연결된 2,3노드는 ArrayList[1]에 [2,3]을 연결하는 방식으로 
표현합니다. 계속해서 인접 리스트로 가중치 있는 그래프를 표현하는 방법을 알아봅시다.
###### ▶여기서도 방향이 있는 그래프를 표현합니다.

#### 인접 리스트로 가중치 있는 그래프 표현하기
가중치가 있는 경우 자료형을 클래스로 사용합니다. 다음은 (도착 노드, 가중치)를 
갖는 Node 클래스를 선언하여 ArrayList에 사용한 것입니다.  
![인접 리스트 가중치](https://github.com/leesulgi66/Algorithm/assets/107823688/b50d8b24-26da-4bd1-9818-b134db14af97)
그림을 보면 ArrayList[1]에 [(2,8), (3,3)]이 연결되어 있습니다. 이는 노드 
1과 2가 가중치 8에지로, 노드 1과 3이 가중치 3에지로 연결되어 있다는 것을 
보여줍니다. 방향성도 고려되어 있습니다. 그래프를 구현하는 다른 방법에 비해 
인접 리스트를 이용한 그래프 구현은 복잡한 편입니다. 하지만 노드와 연결되어 
있는 에지를 탐색하는 시간은 매우 뛰어나며, 노드 개수가 커도 공간 효율이 좋아 
메모리 초과 에러도 발생하지 않습니다. 이런 장점으로 실제 코딩 테스트에서는 
인접 리스트를 이용한 그래프 구현을 선호합니다.  
이후 등장하는 실전 문제는 그래프 구현과 함께 앞에서 공부한 DFS,BFS 를 
복습합니다. 문제를 풀면서 그래프 구현에 익숙해지기 바랍니다.