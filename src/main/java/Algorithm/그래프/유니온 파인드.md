# 유니온 파인드
유니온 파인드(union-find)는 일반적으로 여러 노드가 있을 때 특정 2개의 노드를 
연결해 1개의 집합으로 묶는 union 연산과 두 노드가 같은 집합에 속해 있는지를 
확인하는 find 연산으로 구성되어 있는 알고리즘 입니다.

### 유니온 파인드의 핵심 이론
유니온 파인드는 union, find 연산을 완벽히 이해하는 것이 핵심입니다. 두 연산은 
다음과 같습니다. 이 설명을 염두에 두고 원리를 공부해 봅시다.

![유니온 파인드 1](https://github.com/leesulgi66/Algorithm/assets/107823688/fcecede8-c8b0-4ddd-b9a9-44071e09f7f4)

#### 유니온 파인드의 원리 이해하기
두 연산을 알아봤으므로 이번에는 유니온 파인드 알고리즘 구현 방법을 설명하겠습니다.
1. 유니온 파인드를 표현하는 일반적인 방법은 1차원 배열을 이용하는 것입니다. 처음에는 
노드가 연결되어 있지 않으므로 각 노드가 대표 노드가 됩니다. 각 노드가 모두 대표 노드이므로 
배열은 자시느이 인덱스값을 초기화합니다.
   ![유니온 파인드 2](https://github.com/leesulgi66/Algorithm/assets/107823688/d928435b-042a-435d-980e-a628c89a6c80)
2. 2개의 노드를 선택해 각각의 대표 노드를 찾아 연결하는 union 연산을 수행합니다. 배열을 
보면 1,4와 5,6을 union 연산으로 연결합니다. 배열[4]는 1로, 배열[6]은 5로 업데이트합니다. 
이렇게 업데이트하는 것의 의미를 이해해야 합니다. 1,4의 연결을 예로 들어 설명해 보겠습니다. 
1은 대표노드, 4는 자식 노드로 union 연산을 하므로 배열[4]의 대표 노드를 
1로 설정한 것입니다. 다시 말해 자식 노드로 들어가는 노드값 4를 대표 노드값 1로 
변경한 것입니다. 그 결과 각각의 집합이었던 1,4는 하나로 합쳐집니다.  
▶union(5,6)은 6의 대표 노드를 5로 업데이트 합니다.
   ![유니온 파인드 3](https://github.com/leesulgi66/Algorithm/assets/107823688/7c5c425a-9d98-4792-9737-6f7b9021c4aa)
설명을 잘 따라오고 있나요? 이제 union(4,6)으로 4와6을 연결해 봅니다. 그런데 4,6은 
대표 노드가 아닙니다. 그래서 각 노드의 대표노드를 찾아 올라간 다음 그 대표 노드를 연결합니다. 
지금의 경우 4의 대표노드 1에 6의 대표노드 5를 연결한 것입니다. 배열은 그럼 [1,2,3,1,1,5]가 됩니다. 
배열 상태로 보면 그래프의 연결이 잘 안 보일 수도 있겠지만 다음 find 연산 설명을 보면 위 배열이 
그래프 연결을 잘 나타내고 있다는 것을 쉽게 이해할 수 있을 것입니다.
3. find 연산은 자신이 속한 집합의 대표 노드를 찾는 연산입니다. find 연산은 단순히 
대표 노드를 찾는 역할만 하는 것이 아니라 그래프를 정돈하고 시간 복잡도를 향상시킵니다. 
이 특징은 매우 중요하므로 다음 설명을 집중하여 읽기 바랍니다.  
<br>**find 연산의 작동 원리**
   1. 대상 노드 배열에 index값과 value값이 돌일한지 확인합니다.
   2. 동일하지 않으면 value값이 가리키는 index 위치로 이동합니다.
   3. 이동 위치의 index갑소가 value값이 같을 때까지 1-2를 반복합니다.(대표 노드를 찾을때 까지) 반복이므로 이 부분은 재귀 함수로 구현합니다.
   4. 대표 노드에 도달하면 재귀 함수를 빠져나오면서 거치는 모든 노드값을 루트 노드(대표 노드)값으로 변경합니다.
      ![유니온 파인드 4](https://github.com/leesulgi66/Algorithm/assets/107823688/830f20b8-70b3-4112-8374-2d7947a686e6)

find 연산은 잘 생각하면 시간 복잡도가 줄어드는 효과를 얻게 됩니다. 연산을 할 때 거치는 
노드들이 대표 노드와 바로 연결되는 형태로 변경되는 것을 알 수 있습니다. 이렇게 되면 추 후 노드와 
관련된 find 연산 속도가 O(1)로 변경됩니다. 다음 예로 확인해 보겠습니다.
![유니온 파인드 5](https://github.com/leesulgi66/Algorithm/assets/107823688/9aee19f6-13f7-44c3-b048-dc43c4d7a735)
한 번의 find 연산을 이용해 모든 노드가 루트 노드에 직접 연결되는 형태로 변경되는 것을 
볼 수 있습니다. 이러한 형태로 변경되면 이후 find 연산이 진행될 때 경로 압축의 효과가 
나타납니다. 예를 들어 이후 find(4)연산을 수행하면 한 번의 이동으로 바로 대표 노드를 
찾을 수 있게 되겠죠?  
▶경로 압축은 실제 그래프에서 여러 노드를 거쳐야 하는 경로에서 그래프를 변형해 더 짧은 경로로 갈 수 있도록 함으로써 시간 복잡도를 효과적으로 줄이는 방법을 말합니다.