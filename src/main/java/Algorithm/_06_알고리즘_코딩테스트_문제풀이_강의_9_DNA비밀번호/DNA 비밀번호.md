# DNA 비밀번호

[문제 링크](https://www.acmicpc.net/problem/12891)

### 문제

평소에 문자열을 가지고 노는 것을 좋아하는 민호는 DNA 문자열을 알게 되었다. DNA 문자열은 모든 문자열에 등장하는 문자가 {‘A’, ‘C’, ‘G’, ‘T’} 인 문자열을 말한다. 예를 들어 “ACKA”는 DNA 문자열이 아니지만 “ACCA”는 DNA 문자열이다. 이런 신비한 문자열에 완전히 매료된 민호는 임의의 DNA 문자열을 만들고 만들어진 DNA 문자열의 부분문자열을 비밀번호로 사용하기로 마음먹었다.

하지만 민호는 이러한 방법에는 큰 문제가 있다는 것을 발견했다. 임의의 DNA 문자열의 부분문자열을 뽑았을 때 “AAAA”와 같이 보안에 취약한 비밀번호가 만들어 질 수 있기 때문이다. 그래서 민호는 부분문자열에서 등장하는 문자의 개수가 특정 개수 이상이여야 비밀번호로 사용할 수 있다는 규칙을 만들었다.

임의의 DNA문자열이 “AAACCTGCCAA” 이고 민호가 뽑을 부분문자열의 길이를 4라고 하자. 그리고 부분문자열에 ‘A’ 는 1개 이상, ‘C’는 1개 이상, ‘G’는 1개 이상, ‘T’는 0개 이상이 등장해야 비밀번호로 사용할 수 있다고 하자. 이때 “ACCT” 는 ‘G’ 가 1 개 이상 등장해야 한다는 조건을 만족하지 못해 비밀번호로 사용하지 못한다. 하지만 “GCCA” 은 모든 조건을 만족하기 때문에 비밀번호로 사용할 수 있다.

민호가 만든 임의의 DNA 문자열과 비밀번호로 사용할 부분분자열의 길이, 그리고 {‘A’, ‘C’, ‘G’, ‘T’} 가 각각 몇번 이상 등장해야 비밀번호로 사용할 수 있는지 순서대로 주어졌을 때 민호가 만들 수 있는 비밀번호의 종류의 수를 구하는 프로그램을 작성하자. 단 부분문자열이 등장하는 위치가 다르다면 부분문자열이 같다고 하더라도 다른 문자열로 취급한다.

### 입력

첫 번째 줄에 민호가 임의로 만든 DNA 문자열 길이 |S|와 비밀번호로 사용할 부분문자열의 길이 |P| 가 주어진다. (1 ≤ |P| ≤ |S| ≤ 1,000,000)

두번 째 줄에는 민호가 임의로 만든 DNA 문자열이 주어진다.

세번 째 줄에는 부분문자열에 포함되어야 할 {‘A’, ‘C’, ‘G’, ‘T’} 의 최소 개수가 공백을 구분으로 주어진다. 각각의 수는 |S| 보다 작거나 같은 음이 아닌 정수이며 총 합은 |S| 보다 작거나 같음이 보장된다.

### 출력

첫 번째 줄에 민호가 만들 수 있는 비밀번호의 종류의 수를 출력해라.

***

<table class="table">
        <thead><tr>
<th>예제 입력 1</th>
<th>예제 출력 1</th>
</tr>
</thead>
        <tbody><tr>
<td>9 8</td>
<td>0</td>
</tr>
<tr>
<td>CCTGGATTG</td>
</tr>
<tr>
<td>2 0 1 1</td>
</tr>
</tbody>
      </table>

<table class="table">
        <thead><tr>
<th>예제 입력 2</th>
<th>예제 출력 2</th>
</tr>
</thead>
        <tbody><tr>
<td>4 2</td>
<td>2</td>
</tr>
<tr>
<td>GATA</td>
</tr>
<tr>
<td>1 0 0 1</td>
</tr>
</tbody>
      </table>

___

#### 01 문제 분석하기
P와 S의 길이가 1,000,000으로 매우 크기 때문에 O(n)의 시간 복잡도 알고리즘으로 문제를 해결해야 합니다. 이때 부분 문자열의 길이가 P이므로 슬라이딩 윈도우의 개념을 이용하면 문제를 쉽게 해결할 수 있습니다. 그림을 보며 슬라이딩 윈도우가 무엇인지 설명해 보겠습니다.  
![슬라이딩윈도우](https://github.com/leesulgi66/Algorithm/assets/107823688/e583555d-53d2-4750-aa78-469247150770)

#### 02 손으로 풀어보기
1. S배열과 비밀번호 체크 배열을 저장합니다.
   ![s배열 체크배열](https://github.com/leesulgi66/Algorithm/assets/107823688/40dcf3bb-3bc7-4e4c-b6d4-1e10ba376f0b)   
2. 윈도우에 포함된 문자로 현재 상태 배열을 만듭니다. 그런 다음 현재 상태 배열과 비밀번호 체크 배열을 비교하여 유효 비밀번호 인지 판단합니다.
   ![슬라이딩 윈도우3](https://github.com/leesulgi66/Algorithm/assets/107823688/66606ab1-7966-450a-bd93-a3a02cf2c63d)       
3. 윈도우를 한 칸씩 이동하며 현재 상태 배열을 업데이트합니다. 현재 상태 배열을 업데이트 한 이후에는 비밀번호 체크 배열과 비교하여 비밀번호 유효성을 판단합니다. 현재 상태 배열을 업데이트 할 때는 빠지는 문자열, 신규 문자열만 보고 업데이트 하는 방식으로 진행합니다.  
   ![슬라이딩 4](https://github.com/leesulgi66/Algorithm/assets/107823688/4fa19234-d4cc-483a-87f3-687e7c6373d1)  
위 그림의 경우 윈도우를 한 칸 이동하여 C가 빠지고, G가 추가되어 현재 사애 배열을 1,2,2,3에서 1,1,3,3으로 업데이트 한 것입니다. 비밀번호 체크 배열과 비교했을 때 A가 2보다 작으니 유효 비밀번호가 아닙니다.

이 문제는 슬라이딩 윈도우 원리 이외에도 '실제 문자열과 관련된 배열 처리를 어떻게 할 것인가?', '비밀번호 유효성 검사를 보다 빠르게 할 수 있는 방법이 있을까?' 등 코드 레벨에서 고민이 필요한 부분이 있습니다. 슈도코드와 실제 코드를 보면서 아이디어와 관련된 영감을 얻어보세요.

#### 03 슈도코드 작성하기
```java
// 데이터 저장
S(문자열 크기) P(부분 문자열의 크기)
A(문자열 데이터)
checkArr(비밀번호 체크 배열)
//변수 선언
myArr(현재 상태 배열)
checkSecret(몇 개의 문자와 관련된 개수를 충족했는지 판단하는 변수)
P 범위(0 ~ P -1)만큼 S 배열에 적용하고, 유효한 비밀번호인진 판단
for(i 를 P에서 S까지 반복)
        {
            j선언(i - P)
            // 이 부분은 함수로 별도 구현하기
        }
```
