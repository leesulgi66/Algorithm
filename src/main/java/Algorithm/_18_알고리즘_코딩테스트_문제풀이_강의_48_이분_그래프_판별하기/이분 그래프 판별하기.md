# 이분 그래프 판별하기

[문제 링크](https://www.acmicpc.net/problem/1707)

### 문제
그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.

그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.

### 입력
입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K가 주어진다. 각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V와 간선의 개수 E가 빈 칸을 사이에 두고 순서대로 주어진다. 각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 각 줄에 인접한 두 정점의 번호 u, v (u ≠ v)가 빈 칸을 사이에 두고 주어진다.

### 출력
K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.

### 제한
- 2 ≤ K ≤ 5
- 1 ≤ V ≤ 20,000
- 1 ≤ E ≤ 200,000

***

<table class="table">
        <thead><tr>
<th>예제 입력 1</th>
<th>예제 출력 1</th>
</tr>
</thead>
        <tbody><tr>
<td>2     </td>
<td>YES     </td>
</tr>
<tr>
<td>3 2     </td>
<td>NO     </td>
</tr>
<tr>
<td>1 3     </td>
</tr>
<tr>
<td>2 3     </td>
</tr>
<tr>
<td>4 4     </td>
</tr>
<tr>
<td>1 2    </td>
</tr>
<tr>
<td>2 3     </td>
</tr>
<tr>
<td>3 4    </td>
</tr>
<tr>
<td>4 2     </td>
</tr>
</tbody>
      </table>

___

#### 01 문제 분석하기
노드의 집합을 2개로 나누는데, 인접한 노드끼리 같은 집합이 되지 않도록 
적절하게 임의로 분할할 수 있다고 합니다. 잘 생각해 보면 트리의 경우에는 항상
이분 그래프가 된다는 것을 알 수 있습니다. 사이클이 발생하지 않으면 탐색을 
하면서 다음 노드를 이번 노드와 다른 집합으로 지정하면 되기 때문입니다. 
단, 사이클이 발생했을 때는 이런 이분 그래프가 불가능할때가 있습니다. 
바로 다음과 같을 때입니다.  
![이분 그래프 1](https://github.com/leesulgi66/Algorithm/assets/107823688/6e79ba08-9919-421b-bf94-8d0a869ee5b7)

이떄는 3번 노드르 1번 집합으로 설정하면 1번 노드와 인접하면서 같은 집합에 
속하게 되고, 2번 집합으로 설정하면 2번 노드와 인접하면서 같은 집합에 속하게 돼 
이번 그래프가 불가능 합니다. 그렇다면 이때를 어떻게 도출할 수 있을까요? 
바로 기존의 탐색 매커니즘에서 탐색한 노드에 다시 접근하게 됐을 때 현재 
노드의 집합과 같으면 이분 그래프가 불가능하다는 것으로 판별할 수 있습니다.


#### 02 손으로 풀어보기

1. 입력된 그래프 데이터를 인접 리스트로 구현합니다.
   ![이분 그래프 2](https://github.com/leesulgi66/Algorithm/assets/107823688/7193b89b-0a24-498b-b0ae-7a9138e9a035)
2. 모든 노드로 각각 DFS탐색 알고리즘을 적용해 탐색을 수행합니다. DFS를 실행할 때 
현재 노드에서 연결된 노드 중 이미 방문한 노드가 나와 같은 집함이면 이분 그래프가 
아닌 것으로 판별합니다. 실행 결과가 이분 그래프가 아니면 이후 노드는 
탐색하지 않습니다.  
▶2개 집합을 각각 A,B로 표현샜습니다.  
   ![이분 그래프 3](https://github.com/leesulgi66/Algorithm/assets/107823688/c440fe15-5ded-4383-ba11-551ce23f7e77)  
3. 이분 그래프 여부를 정답으로 출력합니다.
출발 노드(4)와 도착 노드(2)의 집합이 같으므로 이분 그래프 불가능 => NO출력
4. 사례의 개수만틈 과정 1~3을 반복합니다.
▶여기에서 모든 노드로 DFS를 실행하는 이유는 그래프의 모든 노드가 이어져 있지 않고, 
여러 개의 부분 그래프로 이뤄진 케이스가 존재할 수 있기 때문입니다.


#### 03 슈도코드 작성하기
```java
N(노드 개수) M(에지 개수) check(이분 그래프 체크 배열)
A(그래프 데이터 저장 인접 리스트) visited(방문 기록 저장 배열)
N(테스트 케이스)
for(N의 개수만큼 반복하기) {
    V(노드 개수)
    E(에지 개수)
    for(V의 개수만큼 반복하기) {
        A 인접 리스트의 각 ArrayList 초기화하기
    }
    for(M의 개수만큼 반복하기) {
        A의 인접리스트에 그래프 데이터 저장하기    
    }
    for(V의 개수만큼 반복하기) {
        각 노드에서 DFS 실행 -> 결과가 이분 그래프가 아니면 반복 종료
    }
    이분 그래프 여부를 정답으로 출력하기
}

DFS { // DFS 구현하기
    현재 노드 출력하기
    visited 배열에 현재 노드 방문 기록하기
    if(현재 노드의 연결 노드 중 방문하지 않은 노드로) {
        현재 노드와 다른 집합으로 연결 노드 집합 저장하기
        DFS 실행하기(재귀 형태)
    }
    else{
        // 이미 방문한 노드인데, 현재 나의 노드와 같은 집합이면 이분 그래프가 아님
     }
}

```
